/*
 * Copyright (c) 2025 Materials Modelling Lab, The University of Tokyo
 * SPDX-License-Identifier: Apache-2.0
 */

#include "command.hh"

#include <cassert>
#include <cinttypes>
#include <cstring>
#include <filesystem>
#include <iostream>

// Generated by cmake
#include "douka_version.hh"

namespace douka {

static bool show_help(const int argc, char const *const argv[]) {
  static const auto show_help = [argv](std::ostream &os) {
    assert(sizeof(command::names) == sizeof(command::descriptions));

    os << argv[0] << " [Command]" << std::endl;
    os << std::endl;
    os << "Command:" << std::endl;
    for (uint64_t i = 0; i < sizeof(command::names) / sizeof(std::string_view); i++) {
      os << "   " << std::left << std::setw(12) << command::names[i];
      os << command::descriptions[i] << std::endl;
    }
    os << std::endl;
    os << "Options:" << std::endl;
    os << "   --help      (Opt) Print help message" << std::endl;
    os << "   --version   (Opt) Print version" << std::endl;
  };

  if (argc <= 1) {
    show_help(std::cout);
    throw std::invalid_argument("no command given");
  }

  if (strcmp(argv[1], "--help")) {
    return false;
  }
  show_help(std::cout);
  return true;
}

static bool show_version(const int argc, char const *const argv[]) {
  if (argc <= 1) {
    throw std::invalid_argument("no command given");
  }
  if (strcmp(argv[1], "--version")) {
    return false;
  }
  std::cout << DOUKA_FULL_VERSION << std::endl;
  return true;
}

static command::id get_args(const int argc, const char *const argv[]) {
  if (argc <= 1) {
    throw std::invalid_argument("no command given");
  }
  if (command::init::name == argv[1]) {
    return command::id::init;
  } else if (command::predict::name == argv[1]) {
    return command::id::predict;
  } else if (command::filter::name == argv[1]) {
    return command::id::filter;
  } else if (command::obsgen::name == argv[1]) {
    return command::id::obsgen;
  }

  if (!strncmp(argv[1], "--", 2)) {
    throw std::invalid_argument("unknown option" + std::string{argv[1]} + " given");
  }
  throw std::invalid_argument("unknown command" + std::string{argv[1]} + " given");
}
} // namespace douka

int main(int argc, char *argv[]) {
  try {
    if (douka::show_help(argc, argv) || douka::show_version(argc, argv)) {
      return EXIT_SUCCESS;
    }
    const auto id = douka::get_args(argc, argv);
    switch (id) {
    case douka::command::id::init:
      return douka::command::init::entry(argc, argv);
    case douka::command::id::predict:
      return douka::command::predict::entry(argc, argv);
    case douka::command::id::filter:
      return douka::command::filter::entry(argc, argv);
    case douka::command::id::obsgen:
      return douka::command::obsgen::entry(argc, argv);
    default:
      break;
    }
  } catch (const std::exception &e) {
    std::clog << e.what() << std::endl;
    return EXIT_FAILURE;
  }
  return EXIT_FAILURE;
}